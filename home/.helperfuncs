#!/bin/bash
# (c) 2025 Anirudh Acharya
# Helper functions for dotfiles
# detects various system types, OS and architectures

# Guard variable to ensure sourcing only once
if [ -n "${SOURCED_HELPERFUNCS}" ]; then
  return 0 # Exit the script if already sourced
fi

# Set the guard variable
SOURCED_HELPERFUNCS=1

# Logging functions
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

info() {
  echo -e "${BLUE}[INFO]${NC} $1"
}

debuglog() {
  echo -e "${CYAN}[DEBUG: $(date +'%Y-%m-%d %H:%M:%S')]${NC} $1"
}

log() {
  echo -e "${GREEN}[LOG:$(date +'%Y-%m-%d %H:%M:%S')]${NC} $1"
}

errorexit() {
  echo -e "${RED}[ERROR: $(date +'%Y-%m-%d %H:%M:%S')]${NC} $1" >&2
  # exit immediately
  exit 1
}

error() {
  echo -e "${RED}[ERROR: $(date +'%Y-%m-%d %H:%M:%S')]${NC} $1" >&2
}

warn() {
  echo -e "${YELLOW}[WARNING: $(date +'%Y-%m-%d %H:%M:%S')]${NC} $1"
}

debuglog "Helper functions sourced"

# Detect the operating system type
# Returns:
#   - "macos" for macOS
#   - "debian" for Debian-based systems
#   - "fedora" for Fedora-based systems
#   - "arch" for Arch-based systems
#   - "gentoo" for Gentoo-based systems
#   - "slackware" for Slackware-based systems
#   - "linux" for other Linux distributions
#   - "freebsd" for FreeBSD
#   - "openbsd" for OpenBSD
#   - "netbsd" for NetBSD
#   - "dragonfly" for DragonFly BSD
#   - "bsd" for other/unknown BSDs
#   - "unknown" for other systems
detect_os_type() {
  uname_os="$(uname -s)"

  if [[ "${uname_os}" == "Darwin" ]]; then
    echo "macos"
  elif [[ "${uname_os}" == "Linux" ]]; then
    # If it's Linux, check for specific distribution by sourcing /etc/os-release
    if [[ -f /etc/os-release ]]; then
      . /etc/os-release
      case "$ID" in
      debian | ubuntu | linuxmint | pop | elementary | kali | raspbian | zorin)
        echo "debian"
        ;;
      fedora | rhel | centos | rocky | almalinux | ol | oracle)
        echo "fedora"
        ;;
      arch | manjaro | endeavouros | artix | cachyos)
        echo "arch"
        ;;
      gentoo | funtoo | calculate)
        echo "gentoo"
        ;;
      slackware | salix)
        echo "slackware"
        ;;
      *)
        # Fallback to ID_LIKE for derivative distributions
        if [[ "$ID_LIKE" == *debian* ]]; then
          echo "debian"
        elif [[ "$ID_LIKE" == *rhel* || "$ID_LIKE" == *fedora* ]]; then
          echo "fedora"
        elif [[ "$ID_LIKE" == *arch* ]]; then
          echo "arch"
        elif [[ "$ID_LIKE" == *gentoo* ]]; then
          echo "gentoo"
        elif [[ "$ID_LIKE" == *slackware* ]]; then
          echo "slackware"
        else
          # It's a Linux system, but we don't recognize the specific distribution
          echo "linux"
        fi
        ;;
      esac
    else
      # /etc/os-release not found, but we know it's Linux
      echo "linux"
    fi
  else
    # Non-Linux, Non-macOS: Detect BSD variants
    case "${uname_os}" in
    FreeBSD)
      echo "freebsd"
      ;;
    OpenBSD)
      echo "openbsd"
      ;;
    NetBSD)
      echo "netbsd"
      ;;
    DragonFly)
      echo "dragonfly"
      ;;
    *BSD*)
      echo "bsd"
      ;;
    *)
      echo "unknown"
      ;;
    esac
  fi
}

# Detect the architecture type
# Returns:
#   - "x86_64" for x86_64 systems
#   - "aarch64" for ARM64 systems (aarch64, arm64, armv8*, armv9*)
#   - "armv7l" for ARMv7 systems (little endian)
#   - "armv7h" for ARMv7 systems (hard float)
#   - "armv7" for other ARMv7 systems
#   - "armv6" for ARMv6 systems
#   - "armv5" for ARMv5 systems
#   - "ppc64le" for PowerPC 64-bit little-endian systems
#   - "ppc64" for PowerPC 64-bit big-endian systems
#   - "ppc" for PowerPC 32-bit systems
#   - "mips" for MIPS systems (big endian)
#   - "mipsel" for MIPS systems (little endian)
#   - "unknown" for other architectures
detect_arch_type() {
  #debuglog "Detecting architecture type"
  arch="$(uname -m 2>/dev/null || echo unknown)"

  case "$arch" in
  x86_64)
    #debuglog "Detected x86_64 architecture"
    echo "x86_64"
    ;;
  aarch64 | arm64 | armv8* | armv9*)
    #debuglog "Detected aarch64/arm64 architecture"
    echo "aarch64"
    ;;
  armv7l)
    #debuglog "Detected armv7l architecture (little endian)"
    echo "armv7l"
    ;;
  armv7h)
    #debuglog "Detected armv7h architecture (hard float)"
    echo "armv7h"
    ;;
  armv7)
    #debuglog "Detected armv7 architecture"
    echo "armv7"
    ;;
  armv6 | armv6l)
    #debuglog "Detected armv6 architecture"
    echo "armv6"
    ;;
  armv5 | armv5l | armv5te | armv5tel)
    #debuglog "Detected armv5 architecture"
    echo "armv5"
    ;;
  ppc64le | powerpc64le)
    #debuglog "Detected PowerPC 64-bit little-endian"
    echo "ppc64le"
    ;;
  ppc64 | powerpc64)
    #debuglog "Detected PowerPC 64-bit big-endian"
    echo "ppc64"
    ;;
  ppc | powerpc)
    #debuglog "Detected PowerPC 32-bit"
    echo "ppc"
    ;;
  mips)
    #debuglog "Detected mips architecture (big endian)"
    echo "mips"
    ;;
  mipsel | mips64el)
    #debuglog "Detected mipsel architecture (little endian)"
    echo "mipsel"
    ;;
  *)
    # Fallback to /proc/cpuinfo for embedded systems (DDWRT/OpenWRT)
    if [ -f /proc/cpuinfo ]; then
      if grep -qi 'mips' /proc/cpuinfo 2>/dev/null; then
        if grep -qi 'little endian' /proc/cpuinfo 2>/dev/null; then
          #debuglog "Detected mipsel architecture from /proc/cpuinfo"
          echo "mipsel"
        else
          #debuglog "Detected mips architecture from /proc/cpuinfo"
          echo "mips"
        fi
      elif grep -qi 'powerpc\|ppc' /proc/cpuinfo 2>/dev/null; then
        # Try to infer 64-bit vs 32-bit and endianness
        if grep -qi 'ppc64' /proc/cpuinfo 2>/dev/null; then
          if grep -qi 'little endian' /proc/cpuinfo 2>/dev/null; then
            echo "ppc64le"
          else
            echo "ppc64"
          fi
        else
          echo "ppc"
        fi
      elif grep -qi 'ARMv7' /proc/cpuinfo 2>/dev/null; then
        # Attempt to distinguish hard-float vs soft-float if possible
        if command -v readelf >/dev/null 2>&1; then
          if readelf -A /proc/self/exe 2>/dev/null | grep -q 'Tag_ABI_VFP_args'; then
            #debuglog "Detected armv7h (hard-float) via readelf ABI tag"
            echo "armv7h"
          else
            #debuglog "Detected armv7l (likely soft-float) via absence of VFP args tag"
            echo "armv7l"
          fi
        else
          #debuglog "ARMv7 detected but cannot distinguish; returning generic armv7"
          echo "armv7"
        fi
      elif grep -qi 'ARMv6' /proc/cpuinfo 2>/dev/null; then
        #debuglog "Detected armv6 architecture from /proc/cpuinfo"
        echo "armv6"
      elif grep -qi 'ARMv5' /proc/cpuinfo 2>/dev/null; then
        #debuglog "Detected armv5 architecture from /proc/cpuinfo"
        echo "armv5"
      elif grep -qi 'AArch64\|ARMv8\|ARMv9' /proc/cpuinfo 2>/dev/null; then
        #debuglog "Detected aarch64 architecture from /proc/cpuinfo"
        echo "aarch64"
      else
        #debuglog "Unknown architecture"
        echo "unknown"
      fi
    else
      #debuglog "Unknown architecture"
      echo "unknown"
    fi
    ;;
  esac
}

# Detect the shell type
# Returns:
#   - "bash" for bash
#   - "zsh" for zsh
#   - "sh" for sh
#   - "fish" for fish
#   - "tcsh" for tcsh
#   - "ash" for ash
#   - "busybox" for BusyBox shells
#   - "unknown" for other shells
detect_shell_type() {

  exe=$(readlink "/proc/$$/exe" 2>/dev/null)

  #debuglog "Detecting shell type"
  if [[ "$SHELL" == *"/bash" ]]; then
    #debuglog "Detected bash shell"
    echo "bash" # combination of echo and return used to return strings in functions
  elif [[ "$SHELL" == *"/zsh" ]]; then
    #debuglog "Detected zsh shell"
    echo "zsh" # combination of echo and return used to return strings in functions
  elif [[ "$SHELL" == *"/sh" ]]; then
    #debuglog "Detected sh shell"
    if [[ "$exe" == *"/busybox" ]]; then
      echo "busybox"
    else
      echo "sh"
    fi
  elif [[ "$SHELL" == *"/fish" ]]; then
    #debuglog "Detected fish shell"
    echo "fish"
  elif [[ "$SHELL" == *"/tcsh" ]]; then
    #debuglog "Detected tcsh shell"
    echo "tcsh"
  elif [[ "$SHELL" == *"/ash" ]]; then
    #debuglog "Detected ash shell"
    if [[ "$exe" == *"/busybox" ]]; then
      echo "busybox"
    else
      echo "ash"
    fi
  elif [[ "$exe" == *"/busybox" ]]; then
    #debuglog "Detected busybox shell via executable path"
    echo "busybox"
  else
    #debuglog "Unknown shell"
    echo "unknown" # combination of echo and return used to return strings in functions
  fi
}

# check if any shell command is aliases to busybox
# A function to check if a command is an alias and if it points to busybox.
# FIXME: this is currently broken
detect_busybox_alias() {
  local command_name="$1"

  # Use an interactive shell to expand aliases, then capture the type output.
  # The 'type' command with the -t flag outputs the type of command (e.g., alias, file).
  # Without -t, it provides the full definition of the alias.
  alias_info=$(${SHELL} -ic "type $command_name" 2>/dev/null)

  # Check if the command is an alias and if its definition contains "busybox".
  if [[ "$alias_info" == *'BusyBox'* && "$alias_info" == *'multi-call binary'* ]]; then
    echo "busybox_true" # Success: It's an alias to busybox
  else
    echo "busybox_false" # Failure: It's not an alias to busybox
  fi
}

# Detect the Machine type
# Returns:
#   - "pveserver" for PVE Server
#   - "pveguest" for PVE Guest
#   - "router" for ASUS/OpenWRT/DDWRT router
#   - "sbc" for linux on SBC
#   - "client" for Client
detect_machine_type() {
  #debuglog "Detecting machine type"
  # $HOSTNAME only works for bash shells, use more portable way
  #if [[ "${HOSTNAME}" == "ifc6410" ]] || [[ "${HOSTNAME}" == "IFC6410" ]]; then
  host_name=$(hostname)
  if [[ "${host_name}" == "ifc6410" ]] || [[ "${host_name}" == "IFC6410" ]]; then
    #debuglog "Detected SBC"
    echo "sbc" # combination of echo and return used to return strings in functions
  elif [[ "${host_name}" == "mx4300" ]] || [[ "${host_name}" == "MX4300" ]] || [[ "${host_name}" == "RT-AX82U" ]] || [[ "${host_name}" == "rt-ax82u" ]]; then
    #debuglog "Detected Router"
    echo "router" # router linux
  elif [ -f /proc/1/environ ]; then
    if [ -x "$(command -v pveversion)" ]; then
      #debuglog "Detected PVE server"
      echo "pveserver" # combination of echo and return used to return strings in functions
    elif [ -x "$(command -v systemd-detect-virt)" ]; then
      #debuglog "Detected PVE guest"
      if [[ $(/usr/bin/systemd-detect-virt) == "none" ]]; then
        echo "client" # combination of echo and return used to return strings in functions
      else
        echo "pveguest" # combination of echo and return used to return strings in functions
      fi
    else
      echo "unknown linux" # combination of echo and return used to return strings in functions
    fi
  else
    #debuglog "Detected client"
    echo "unknown" # combination of echo and return used to return strings in functions
  fi
}
